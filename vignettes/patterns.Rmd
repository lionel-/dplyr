---
title: "Patterns of dplyr operations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to dplyr}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
library(dplyr)
library(ggplot2)
set.seed(1014)
```

The main design goal of dplyr is to be intuitive. Ideally, it should be obvious from a glance what a piece of dplyr is about, and what it does. But despite this apparent simplicitly, many different things happen under the hood. This vignette explains how each dplyr verb behaves to help you become more proficient in writing R and tidyverse code.

The dplyr verbs can be categorised along three main properties:

- How they reshape the data frame. Many verbs may create columns, other can remove columns. Some shrink the number of rows, others make it longer. Quite often, the shape does not change.

- The type of data passed in by the user. Is the data created on the spot by computing new columns or is the data purely selected within the data frame? In the former case, the verb takes __actions__, in the latter case, it takes __selections__.

- How the verb handle groups. Most of the time, grouped data frames produce different results than ungrouped data frames because the computations occur within group levels.


## Actions and selections {#sec:actions-selections}

Actions and selections are two kinds of operations in dplyr and the tidyverse. We call __operations__ the arguments supplied by the user that either create new columns or vectors, or select them from a data frame. An operation may be very simple. For instance, the following examples feature two operations `eye_color` and `hair_color`:

```{r}
starwars %>% arrange(mass, hair_color)

starwars %>% select(mass, hair_color)
```

But really, the operations can become as complex as you like:

```{r}
starwars %>% arrange(-mass, desc(paste(hair_color, eye_color)))

starwars %>% select(1 + 2, intersect(starts_with("hair"), ends_with("color")))
```

While all operations look like R code, they are actually interpreted a little differently, depending on the dplyr verb at the receiving end. The key too be effective at writing more complex dplyr operations is to understand the difference between two kinds of operations, actions and selections.


### Actions

Actions are the most common flavour of dplyr operations. They behave just like any ordinary R code, with a few added features.


#### Data creation

All actions create new data. To illustrate this, we use `transmute()`, a dplyr verb that takes actions and returns the result of those actions, preserving the shape of the data frame:

```{r}
starwars %>% transmute(1 + 2)
```

We get a one-column data frame containing the result of `1 + 2`, recycled to the total data frame size, and given an automatic name to remind how the data was created.


#### Data masking

Actions are computed in the context of your data frame. This means you can refer to your columns as if they were actual objects in your workspace. We call this __data masking__ because the columns have precedence over other objects in your workspace, i.e. they mask these objects.

```{r}
height <- 500

# In the workspace, we can safely refer to workspace objects:
height / 100

# In the data mask, they are masked by the data:
starwars %>% transmute(height / 100)
```


#### Grouping

When you supply a grouped tibble, actions are automatically computed within groups. This is a dplyr feature that isn't available in all data-masking APIs, for instance actions supplied to `ggplot2::aes()` are not computed within groups.

```{r}
# Standardising by the population standard deviation
starwars %>% transmute(height = height / sd(height, na.rm = TRUE))

# Standardising by within-group standard deviations
starwars %>% group_by(eye_color) %>% transmute(height = height / sd(height, na.rm = TRUE))
```


### Selections

The usage of `dplyr::select()` looks similar to other verbs. In some cases, you'll get exactly the same results:

```{r}
starwars %>% select(height)

starwars %>% transmute(height)
```

However `select()` actually uses a different mechanism under the hood. The arguments to `select()` are _selections_, not actions. Whereas action verbs take entire vectors as arguments, selecting verbs take column names or column positions. Observe the difference:

```{r}
starwars %>% select(2)

starwars %>% transmute(2)
```

The key feature of selecting verbs is that column names represent their own _position_ inside the data frame. From the persective of `select()`, `height` is the same as `2` because it is the second column in the `starwars` data frame. On the other hand, `transmute()` takes actions and interprets `2` as a new column recycled to the full data frame size.

There are two reasons for this difference.

1. It makes it possible to select ranges of columns with `start:end`. For instance, `name:mass` expands to `1:3`. This couldn't work if `name` and `mass` represented the entire columns rather than just their positions.

2. It allows overlapping selections. Take the sets of columns starting with the letter `"h"` and of columns ending with the suffix `"_color"`:

   ```{r}
   starwars %>% select(starts_with("h")) %>% names()

   starwars %>% select(ends_with("_color")) %>% names()
   ```

   It is easy to select the union of those overlapping sets:

   ```{r}
   starwars %>% select(starts_with("h"), ends_with("_color")) %>% names()
   ```

   To achieve this, `select()` needs unique identifiers for the columns, which the column positions provide.


### The origins of actions and selections

#### Data masking

Actions are operations evaluated with a data mask. The notion of actions is embedded deep in the R language:

```{r}
result <- with(starwars, mass / 100)
head(result)
```

The low-level function `eval()` makes it easy to implement actions:

```{r}
expr <- quote(mass / 100)
result <- eval(expr, starwars)
head(result)
```

Tidyverse packages use tidy eval, an extension of base R data masking provided by the [rlang](https://rlang.r-lib.org/) package.


#### The `select` argument

Selections were introduced in base R with the `select` argument of `base::subset()`:

```{r}
subset(starwars, select = name:mass)
```

Selections are implemented with a special data mask that contains column positions:

```{r}
mask <- as.list(seq_along(starwars))
names(mask) <- names(starwars)
str(mask)
```
